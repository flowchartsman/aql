// Code generated by pigeon; DO NOT EDIT.

package parser

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"
)

// helper method to exfiltrate pigeon's generated error type
func getParseError(err error) error {
	switch ev := err.(type) {
	case errList:
		if pe, ok := ev[0].(*parserError); ok {
			return &ParseError{
				Inner:    pe.Inner,
				Line:     pe.pos.line,
				Column:   pe.pos.col,
				Offset:   pe.pos.offset,
				Prefix:   pe.prefix,
				Expected: pe.expected,
			}
		}
	}
	return err
}

// TODO: In addition to type annotation, there needs to be a semantic analysis layer to check type and arity concordance and collapse unncessary clauses and such. This will tie in with operator "registration", which allows new operators to specify their input types and arity or even extend the operating types of extant operators. This may require a new structure past the basic node.

// TODO: PLUGINS
// operator: accepts, validate, arity
// function: types for value generators? multi-arity?, something to specify whether function needs to be rerun for each comparator.

// special exceptions for operators like "exists", which should only ever have an arity of one

// ParseQuery parses the AQL query string and returns the query root node
func ParseQuery(query string) (*Node, error) {
	v, err := Parse("", []byte(query))
	if err != nil {
		return nil, getParseError(err)
	}
	return getRootNode(v)
}

// ParseQueryReader parses the AQL query from an io.Reader and returns the query
// root node
func ParseQueryReader(queryReader io.Reader) (*Node, error) {
	v, err := ParseReader("", queryReader)
	if err != nil {
		return nil, getParseError(err)
	}
	return getRootNode(v)
}

var g = &grammar{
	rules: []*rule{
		{
			name: "Start",
			pos:  position{line: 56, col: 1, offset: 1636},
			expr: &actionExpr{
				pos: position{line: 56, col: 10, offset: 1645},
				run: (*parser).callonStart1,
				expr: &seqExpr{
					pos: position{line: 56, col: 10, offset: 1645},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 56, col: 10, offset: 1645},
							label: "query",
							expr: &ruleRefExpr{
								pos:  position{line: 56, col: 16, offset: 1651},
								name: "Query",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 56, col: 22, offset: 1657},
							name: "EOF",
						},
					},
				},
			},
		},
		{
			name: "Query",
			pos:  position{line: 60, col: 1, offset: 1688},
			expr: &actionExpr{
				pos: position{line: 60, col: 10, offset: 1697},
				run: (*parser).callonQuery1,
				expr: &seqExpr{
					pos: position{line: 60, col: 10, offset: 1697},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 60, col: 10, offset: 1697},
							name: "_",
						},
						&labeledExpr{
							pos:   position{line: 60, col: 12, offset: 1699},
							label: "clause",
							expr: &ruleRefExpr{
								pos:  position{line: 60, col: 19, offset: 1706},
								name: "OrClause",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 60, col: 28, offset: 1715},
							name: "_",
						},
					},
				},
			},
		},
		{
			name: "OrClause",
			pos:  position{line: 68, col: 1, offset: 1765},
			expr: &choiceExpr{
				pos: position{line: 68, col: 13, offset: 1777},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 68, col: 13, offset: 1777},
						run: (*parser).callonOrClause2,
						expr: &seqExpr{
							pos: position{line: 68, col: 13, offset: 1777},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 68, col: 13, offset: 1777},
									label: "lhs",
									expr: &ruleRefExpr{
										pos:  position{line: 68, col: 17, offset: 1781},
										name: "AndClause",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 68, col: 27, offset: 1791},
									name: "space",
								},
								&ruleRefExpr{
									pos:  position{line: 68, col: 33, offset: 1797},
									name: "logicalOR",
								},
								&ruleRefExpr{
									pos:  position{line: 68, col: 43, offset: 1807},
									name: "space",
								},
								&labeledExpr{
									pos:   position{line: 68, col: 49, offset: 1813},
									label: "rhs",
									expr: &ruleRefExpr{
										pos:  position{line: 68, col: 53, offset: 1817},
										name: "OrClause",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 74, col: 5, offset: 1943},
						name: "AndClause",
					},
				},
			},
		},
		{
			name: "AndClause",
			pos:  position{line: 76, col: 1, offset: 1954},
			expr: &choiceExpr{
				pos: position{line: 76, col: 14, offset: 1967},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 76, col: 14, offset: 1967},
						run: (*parser).callonAndClause2,
						expr: &seqExpr{
							pos: position{line: 76, col: 14, offset: 1967},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 76, col: 14, offset: 1967},
									label: "lhs",
									expr: &ruleRefExpr{
										pos:  position{line: 76, col: 18, offset: 1971},
										name: "NotClause",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 76, col: 28, offset: 1981},
									name: "space",
								},
								&ruleRefExpr{
									pos:  position{line: 76, col: 34, offset: 1987},
									name: "logicalAND",
								},
								&ruleRefExpr{
									pos:  position{line: 76, col: 45, offset: 1998},
									name: "space",
								},
								&labeledExpr{
									pos:   position{line: 76, col: 51, offset: 2004},
									label: "rhs",
									expr: &ruleRefExpr{
										pos:  position{line: 76, col: 55, offset: 2008},
										name: "AndClause",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 82, col: 5, offset: 2136},
						name: "NotClause",
					},
				},
			},
		},
		{
			name: "NotClause",
			pos:  position{line: 84, col: 1, offset: 2147},
			expr: &choiceExpr{
				pos: position{line: 84, col: 14, offset: 2160},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 84, col: 14, offset: 2160},
						run: (*parser).callonNotClause2,
						expr: &seqExpr{
							pos: position{line: 84, col: 14, offset: 2160},
							exprs: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 84, col: 14, offset: 2160},
									name: "logicalNOT",
								},
								&labeledExpr{
									pos:   position{line: 84, col: 25, offset: 2171},
									label: "cmp",
									expr: &ruleRefExpr{
										pos:  position{line: 84, col: 29, offset: 2175},
										name: "Comparison",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 90, col: 5, offset: 2296},
						name: "Comparison",
					},
				},
			},
		},
		{
			name: "Comparison",
			pos:  position{line: 92, col: 1, offset: 2308},
			expr: &choiceExpr{
				pos: position{line: 92, col: 15, offset: 2322},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 92, col: 15, offset: 2322},
						run: (*parser).callonComparison2,
						expr: &seqExpr{
							pos: position{line: 92, col: 15, offset: 2322},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 92, col: 15, offset: 2322},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 92, col: 19, offset: 2326},
									expr: &ruleRefExpr{
										pos:  position{line: 92, col: 19, offset: 2326},
										name: "space",
									},
								},
								&labeledExpr{
									pos:   position{line: 92, col: 26, offset: 2333},
									label: "query",
									expr: &ruleRefExpr{
										pos:  position{line: 92, col: 32, offset: 2339},
										name: "OrClause",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 92, col: 41, offset: 2348},
									expr: &ruleRefExpr{
										pos:  position{line: 92, col: 41, offset: 2348},
										name: "space",
									},
								},
								&litMatcher{
									pos:        position{line: 92, col: 48, offset: 2355},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 94, col: 6, offset: 2387},
						run: (*parser).callonComparison12,
						expr: &seqExpr{
							pos: position{line: 94, col: 6, offset: 2387},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 94, col: 6, offset: 2387},
									label: "field",
									expr: &ruleRefExpr{
										pos:  position{line: 94, col: 12, offset: 2393},
										name: "Field",
									},
								},
								&litMatcher{
									pos:        position{line: 94, col: 18, offset: 2399},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&labeledExpr{
									pos:   position{line: 94, col: 22, offset: 2403},
									label: "operation",
									expr: &zeroOrOneExpr{
										pos: position{line: 94, col: 32, offset: 2413},
										expr: &ruleRefExpr{
											pos:  position{line: 94, col: 32, offset: 2413},
											name: "opCOMP",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 94, col: 40, offset: 2421},
									expr: &ruleRefExpr{
										pos:  position{line: 94, col: 40, offset: 2421},
										name: "space",
									},
								},
								&labeledExpr{
									pos:   position{line: 94, col: 47, offset: 2428},
									label: "values",
									expr: &ruleRefExpr{
										pos:  position{line: 94, col: 54, offset: 2435},
										name: "ValueList",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Field",
			pos:  position{line: 116, col: 1, offset: 2848},
			expr: &actionExpr{
				pos: position{line: 116, col: 10, offset: 2857},
				run: (*parser).callonField1,
				expr: &labeledExpr{
					pos:   position{line: 116, col: 10, offset: 2857},
					label: "pieces",
					expr: &seqExpr{
						pos: position{line: 116, col: 18, offset: 2865},
						exprs: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 116, col: 18, offset: 2865},
								name: "FieldPiece",
							},
							&zeroOrMoreExpr{
								pos: position{line: 116, col: 29, offset: 2876},
								expr: &seqExpr{
									pos: position{line: 116, col: 30, offset: 2877},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 116, col: 30, offset: 2877},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
										&ruleRefExpr{
											pos:  position{line: 116, col: 34, offset: 2881},
											name: "FieldPiece",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "FieldPiece",
			pos:  position{line: 130, col: 1, offset: 3239},
			expr: &choiceExpr{
				pos: position{line: 130, col: 15, offset: 3253},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 130, col: 15, offset: 3253},
						name: "QuotedFieldPiece",
					},
					&ruleRefExpr{
						pos:  position{line: 130, col: 34, offset: 3272},
						name: "UnquotedFieldPiece",
					},
					&ruleRefExpr{
						pos:  position{line: 130, col: 55, offset: 3293},
						name: "Star",
					},
				},
			},
		},
		{
			name: "UnquotedFieldPiece",
			pos:  position{line: 132, col: 1, offset: 3299},
			expr: &actionExpr{
				pos: position{line: 132, col: 23, offset: 3321},
				run: (*parser).callonUnquotedFieldPiece1,
				expr: &oneOrMoreExpr{
					pos: position{line: 132, col: 23, offset: 3321},
					expr: &charClassMatcher{
						pos:        position{line: 132, col: 23, offset: 3321},
						val:        "[a-z0-9_-]i",
						chars:      []rune{'_', '-'},
						ranges:     []rune{'a', 'z', '0', '9'},
						ignoreCase: true,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "QuotedFieldPiece",
			pos:  position{line: 136, col: 1, offset: 3370},
			expr: &ruleRefExpr{
				pos:  position{line: 136, col: 21, offset: 3390},
				name: "QuotedValue",
			},
		},
		{
			name: "Star",
			pos:  position{line: 138, col: 1, offset: 3403},
			expr: &actionExpr{
				pos: position{line: 138, col: 9, offset: 3411},
				run: (*parser).callonStar1,
				expr: &litMatcher{
					pos:        position{line: 138, col: 9, offset: 3411},
					val:        "*",
					ignoreCase: false,
					want:       "\"*\"",
				},
			},
		},
		{
			name: "ValueList",
			pos:  position{line: 147, col: 1, offset: 3529},
			expr: &choiceExpr{
				pos: position{line: 147, col: 14, offset: 3542},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 147, col: 14, offset: 3542},
						run: (*parser).callonValueList2,
						expr: &seqExpr{
							pos: position{line: 147, col: 14, offset: 3542},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 147, col: 14, offset: 3542},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 147, col: 18, offset: 3546},
									expr: &ruleRefExpr{
										pos:  position{line: 147, col: 18, offset: 3546},
										name: "space",
									},
								},
								&labeledExpr{
									pos:   position{line: 147, col: 25, offset: 3553},
									label: "first",
									expr: &ruleRefExpr{
										pos:  position{line: 147, col: 31, offset: 3559},
										name: "Value",
									},
								},
								&labeledExpr{
									pos:   position{line: 147, col: 37, offset: 3565},
									label: "rest",
									expr: &zeroOrMoreExpr{
										pos: position{line: 147, col: 42, offset: 3570},
										expr: &seqExpr{
											pos: position{line: 147, col: 44, offset: 3572},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 147, col: 44, offset: 3572},
													expr: &ruleRefExpr{
														pos:  position{line: 147, col: 44, offset: 3572},
														name: "space",
													},
												},
												&litMatcher{
													pos:        position{line: 147, col: 51, offset: 3579},
													val:        ",",
													ignoreCase: false,
													want:       "\",\"",
												},
												&zeroOrOneExpr{
													pos: position{line: 147, col: 55, offset: 3583},
													expr: &ruleRefExpr{
														pos:  position{line: 147, col: 55, offset: 3583},
														name: "space",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 147, col: 62, offset: 3590},
													name: "Value",
												},
											},
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 147, col: 71, offset: 3599},
									expr: &ruleRefExpr{
										pos:  position{line: 147, col: 71, offset: 3599},
										name: "space",
									},
								},
								&litMatcher{
									pos:        position{line: 147, col: 78, offset: 3606},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 149, col: 5, offset: 3658},
						run: (*parser).callonValueList21,
						expr: &labeledExpr{
							pos:   position{line: 149, col: 5, offset: 3658},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 149, col: 11, offset: 3664},
								name: "Value",
							},
						},
					},
				},
			},
		},
		{
			name: "Value",
			pos:  position{line: 153, col: 1, offset: 3716},
			expr: &choiceExpr{
				pos: position{line: 153, col: 10, offset: 3725},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 153, col: 10, offset: 3725},
						name: "QuotedValue",
					},
					&ruleRefExpr{
						pos:  position{line: 154, col: 1, offset: 3740},
						name: "RegexValue",
					},
					&actionExpr{
						pos: position{line: 155, col: 1, offset: 3754},
						run: (*parser).callonValue4,
						expr: &ruleRefExpr{
							pos:  position{line: 155, col: 1, offset: 3754},
							name: "BareValue",
						},
					},
				},
			},
		},
		{
			name: "QuotedValue",
			pos:  position{line: 163, col: 1, offset: 3865},
			expr: &actionExpr{
				pos: position{line: 163, col: 15, offset: 3881},
				run: (*parser).callonQuotedValue1,
				expr: &seqExpr{
					pos: position{line: 163, col: 15, offset: 3881},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 163, col: 15, offset: 3881},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 163, col: 19, offset: 3885},
							expr: &choiceExpr{
								pos: position{line: 163, col: 21, offset: 3887},
								alternatives: []interface{}{
									&seqExpr{
										pos: position{line: 163, col: 21, offset: 3887},
										exprs: []interface{}{
											&notExpr{
												pos: position{line: 163, col: 21, offset: 3887},
												expr: &ruleRefExpr{
													pos:  position{line: 163, col: 22, offset: 3888},
													name: "EscapedChar",
												},
											},
											&anyMatcher{
												line: 163, col: 34, offset: 3900,
											},
										},
									},
									&seqExpr{
										pos: position{line: 163, col: 38, offset: 3904},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 163, col: 38, offset: 3904},
												val:        "\\",
												ignoreCase: false,
												want:       "\"\\\\\"",
											},
											&ruleRefExpr{
												pos:  position{line: 163, col: 43, offset: 3909},
												name: "EscapeSequence",
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 163, col: 61, offset: 3927},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
					},
				},
			},
		},
		{
			name: "EscapedChar",
			pos:  position{line: 168, col: 1, offset: 4045},
			expr: &charClassMatcher{
				pos:        position{line: 168, col: 15, offset: 4061},
				val:        "[\\x00-\\x1f\"\\\\]",
				chars:      []rune{'"', '\\'},
				ranges:     []rune{'\x00', '\x1f'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "EscapeSequence",
			pos:  position{line: 170, col: 1, offset: 4077},
			expr: &choiceExpr{
				pos: position{line: 170, col: 18, offset: 4096},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 170, col: 18, offset: 4096},
						name: "SingleCharEscape",
					},
					&ruleRefExpr{
						pos:  position{line: 170, col: 37, offset: 4115},
						name: "UnicodeEscape",
					},
				},
			},
		},
		{
			name: "SingleCharEscape",
			pos:  position{line: 172, col: 1, offset: 4130},
			expr: &charClassMatcher{
				pos:        position{line: 172, col: 20, offset: 4151},
				val:        "[\"\\\\/bfnrt]",
				chars:      []rune{'"', '\\', '/', 'b', 'f', 'n', 'r', 't'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "UnicodeEscape",
			pos:  position{line: 174, col: 1, offset: 4164},
			expr: &seqExpr{
				pos: position{line: 174, col: 17, offset: 4182},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 174, col: 17, offset: 4182},
						val:        "u",
						ignoreCase: false,
						want:       "\"u\"",
					},
					&ruleRefExpr{
						pos:  position{line: 174, col: 21, offset: 4186},
						name: "HexDigit",
					},
					&ruleRefExpr{
						pos:  position{line: 174, col: 30, offset: 4195},
						name: "HexDigit",
					},
					&ruleRefExpr{
						pos:  position{line: 174, col: 39, offset: 4204},
						name: "HexDigit",
					},
					&ruleRefExpr{
						pos:  position{line: 174, col: 48, offset: 4213},
						name: "HexDigit",
					},
				},
			},
		},
		{
			name: "HexDigit",
			pos:  position{line: 176, col: 1, offset: 4223},
			expr: &charClassMatcher{
				pos:        position{line: 176, col: 12, offset: 4236},
				val:        "[0-9a-f]i",
				ranges:     []rune{'0', '9', 'a', 'f'},
				ignoreCase: true,
				inverted:   false,
			},
		},
		{
			name: "ValueChars",
			pos:  position{line: 178, col: 1, offset: 4247},
			expr: &charClassMatcher{
				pos:        position{line: 178, col: 15, offset: 4261},
				val:        "[a-zA-Z0-9 !]",
				chars:      []rune{' ', '!'},
				ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "RegexValue",
			pos:  position{line: 180, col: 1, offset: 4276},
			expr: &actionExpr{
				pos: position{line: 180, col: 14, offset: 4291},
				run: (*parser).callonRegexValue1,
				expr: &seqExpr{
					pos: position{line: 180, col: 14, offset: 4291},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 180, col: 14, offset: 4291},
							val:        "/",
							ignoreCase: false,
							want:       "\"/\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 180, col: 18, offset: 4295},
							expr: &ruleRefExpr{
								pos:  position{line: 180, col: 18, offset: 4295},
								name: "RegexChar",
							},
						},
						&litMatcher{
							pos:        position{line: 180, col: 29, offset: 4306},
							val:        "/",
							ignoreCase: false,
							want:       "\"/\"",
						},
					},
				},
			},
		},
		{
			name: "RegexChar",
			pos:  position{line: 186, col: 1, offset: 4560},
			expr: &choiceExpr{
				pos: position{line: 186, col: 13, offset: 4574},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 186, col: 13, offset: 4574},
						exprs: []interface{}{
							&notExpr{
								pos: position{line: 186, col: 13, offset: 4574},
								expr: &choiceExpr{
									pos: position{line: 186, col: 16, offset: 4577},
									alternatives: []interface{}{
										&litMatcher{
											pos:        position{line: 186, col: 16, offset: 4577},
											val:        "/",
											ignoreCase: false,
											want:       "\"/\"",
										},
										&litMatcher{
											pos:        position{line: 186, col: 22, offset: 4583},
											val:        "\\",
											ignoreCase: false,
											want:       "\"\\\\\"",
										},
										&ruleRefExpr{
											pos:  position{line: 186, col: 29, offset: 4590},
											name: "EOL",
										},
									},
								},
							},
							&anyMatcher{
								line: 186, col: 34, offset: 4595,
							},
						},
					},
					&seqExpr{
						pos: position{line: 186, col: 38, offset: 4599},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 186, col: 38, offset: 4599},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
							&ruleRefExpr{
								pos:  position{line: 186, col: 43, offset: 4604},
								name: "RegexEscape",
							},
						},
					},
				},
			},
		},
		{
			name: "RegexEscape",
			pos:  position{line: 187, col: 1, offset: 4616},
			expr: &seqExpr{
				pos: position{line: 187, col: 15, offset: 4632},
				exprs: []interface{}{
					&notExpr{
						pos: position{line: 187, col: 15, offset: 4632},
						expr: &choiceExpr{
							pos: position{line: 187, col: 17, offset: 4634},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 187, col: 17, offset: 4634},
									name: "EOL",
								},
								&ruleRefExpr{
									pos:  position{line: 187, col: 23, offset: 4640},
									name: "EOF",
								},
							},
						},
					},
					&anyMatcher{
						line: 187, col: 29, offset: 4646,
					},
				},
			},
		},
		{
			name: "BareValue",
			pos:  position{line: 193, col: 1, offset: 4946},
			expr: &choiceExpr{
				pos: position{line: 193, col: 15, offset: 4960},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 193, col: 15, offset: 4960},
						name: "Timestamp",
					},
					&ruleRefExpr{
						pos:  position{line: 194, col: 15, offset: 4984},
						name: "CIDRValue",
					},
					&ruleRefExpr{
						pos:  position{line: 195, col: 15, offset: 5008},
						name: "NumericValue",
					},
					&ruleRefExpr{
						pos:  position{line: 196, col: 15, offset: 5035},
						name: "ExistsValue",
					},
					&ruleRefExpr{
						pos:  position{line: 197, col: 15, offset: 5061},
						name: "BoolValue",
					},
				},
			},
		},
		{
			name: "ExistsValue",
			pos:  position{line: 200, col: 1, offset: 5119},
			expr: &litMatcher{
				pos:        position{line: 200, col: 16, offset: 5134},
				val:        "exists",
				ignoreCase: false,
				want:       "\"exists\"",
			},
		},
		{
			name: "BoolValue",
			pos:  position{line: 202, col: 1, offset: 5144},
			expr: &choiceExpr{
				pos: position{line: 202, col: 14, offset: 5157},
				alternatives: []interface{}{
					&litMatcher{
						pos:        position{line: 202, col: 14, offset: 5157},
						val:        "false",
						ignoreCase: false,
						want:       "\"false\"",
					},
					&litMatcher{
						pos:        position{line: 202, col: 24, offset: 5167},
						val:        "true",
						ignoreCase: false,
						want:       "\"true\"",
					},
				},
			},
		},
		{
			name: "NumericValue",
			pos:  position{line: 204, col: 1, offset: 5175},
			expr: &seqExpr{
				pos: position{line: 204, col: 17, offset: 5191},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 204, col: 17, offset: 5191},
						expr: &litMatcher{
							pos:        position{line: 204, col: 17, offset: 5191},
							val:        "-",
							ignoreCase: false,
							want:       "\"-\"",
						},
					},
					&choiceExpr{
						pos: position{line: 204, col: 23, offset: 5197},
						alternatives: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 204, col: 23, offset: 5197},
								name: "Float",
							},
							&ruleRefExpr{
								pos:  position{line: 204, col: 31, offset: 5205},
								name: "Integer",
							},
						},
					},
				},
			},
		},
		{
			name: "Float",
			pos:  position{line: 206, col: 1, offset: 5215},
			expr: &seqExpr{
				pos: position{line: 206, col: 10, offset: 5224},
				exprs: []interface{}{
					&oneOrMoreExpr{
						pos: position{line: 206, col: 10, offset: 5224},
						expr: &charClassMatcher{
							pos:        position{line: 206, col: 10, offset: 5224},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&litMatcher{
						pos:        position{line: 206, col: 17, offset: 5231},
						val:        ".",
						ignoreCase: false,
						want:       "\".\"",
					},
					&oneOrMoreExpr{
						pos: position{line: 206, col: 21, offset: 5235},
						expr: &charClassMatcher{
							pos:        position{line: 206, col: 21, offset: 5235},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
				},
			},
		},
		{
			name: "Integer",
			pos:  position{line: 208, col: 1, offset: 5243},
			expr: &oneOrMoreExpr{
				pos: position{line: 208, col: 12, offset: 5254},
				expr: &charClassMatcher{
					pos:        position{line: 208, col: 12, offset: 5254},
					val:        "[0-9]",
					ranges:     []rune{'0', '9'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name: "CIDRValue",
			pos:  position{line: 210, col: 1, offset: 5262},
			expr: &actionExpr{
				pos: position{line: 210, col: 14, offset: 5275},
				run: (*parser).callonCIDRValue1,
				expr: &seqExpr{
					pos: position{line: 210, col: 14, offset: 5275},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 210, col: 14, offset: 5275},
							name: "Octet",
						},
						&litMatcher{
							pos:        position{line: 210, col: 20, offset: 5281},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&ruleRefExpr{
							pos:  position{line: 210, col: 24, offset: 5285},
							name: "Octet",
						},
						&litMatcher{
							pos:        position{line: 210, col: 30, offset: 5291},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&ruleRefExpr{
							pos:  position{line: 210, col: 34, offset: 5295},
							name: "Octet",
						},
						&litMatcher{
							pos:        position{line: 210, col: 40, offset: 5301},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&ruleRefExpr{
							pos:  position{line: 210, col: 44, offset: 5305},
							name: "Octet",
						},
						&litMatcher{
							pos:        position{line: 210, col: 50, offset: 5311},
							val:        "/",
							ignoreCase: false,
							want:       "\"/\"",
						},
						&charClassMatcher{
							pos:        position{line: 210, col: 54, offset: 5315},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
						&zeroOrOneExpr{
							pos: position{line: 210, col: 59, offset: 5320},
							expr: &charClassMatcher{
								pos:        position{line: 210, col: 59, offset: 5320},
								val:        "[0-9]",
								ranges:     []rune{'0', '9'},
								ignoreCase: false,
								inverted:   false,
							},
						},
					},
				},
			},
		},
		{
			name: "Octet",
			pos:  position{line: 217, col: 1, offset: 5576},
			expr: &seqExpr{
				pos: position{line: 217, col: 10, offset: 5585},
				exprs: []interface{}{
					&charClassMatcher{
						pos:        position{line: 217, col: 10, offset: 5585},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrOneExpr{
						pos: position{line: 217, col: 15, offset: 5590},
						expr: &charClassMatcher{
							pos:        position{line: 217, col: 15, offset: 5590},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 217, col: 21, offset: 5596},
						expr: &charClassMatcher{
							pos:        position{line: 217, col: 21, offset: 5596},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
				},
			},
		},
		{
			name: "Timestamp",
			pos:  position{line: 220, col: 1, offset: 5616},
			expr: &choiceExpr{
				pos: position{line: 220, col: 14, offset: 5629},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 220, col: 14, offset: 5629},
						name: "dateTime",
					},
					&ruleRefExpr{
						pos:  position{line: 220, col: 25, offset: 5640},
						name: "fullDate",
					},
				},
			},
		},
		{
			name: "dateTime",
			pos:  position{line: 223, col: 1, offset: 5669},
			expr: &seqExpr{
				pos: position{line: 223, col: 13, offset: 5681},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 223, col: 13, offset: 5681},
						name: "fullDate",
					},
					&choiceExpr{
						pos: position{line: 223, col: 23, offset: 5691},
						alternatives: []interface{}{
							&litMatcher{
								pos:        position{line: 223, col: 23, offset: 5691},
								val:        "t",
								ignoreCase: true,
								want:       "\"T\"i",
							},
							&litMatcher{
								pos:        position{line: 223, col: 30, offset: 5698},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 223, col: 35, offset: 5703},
						name: "fullTime",
					},
				},
			},
		},
		{
			name: "fullDate",
			pos:  position{line: 224, col: 1, offset: 5712},
			expr: &seqExpr{
				pos: position{line: 224, col: 13, offset: 5724},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 224, col: 13, offset: 5724},
						name: "dateFullyear",
					},
					&litMatcher{
						pos:        position{line: 224, col: 26, offset: 5737},
						val:        "-",
						ignoreCase: false,
						want:       "\"-\"",
					},
					&ruleRefExpr{
						pos:  position{line: 224, col: 30, offset: 5741},
						name: "dateMonth",
					},
					&litMatcher{
						pos:        position{line: 224, col: 40, offset: 5751},
						val:        "-",
						ignoreCase: false,
						want:       "\"-\"",
					},
					&ruleRefExpr{
						pos:  position{line: 224, col: 44, offset: 5755},
						name: "dateMday",
					},
				},
			},
		},
		{
			name: "dateFullyear",
			pos:  position{line: 226, col: 1, offset: 5765},
			expr: &ruleRefExpr{
				pos:  position{line: 226, col: 17, offset: 5781},
				name: "Digit4",
			},
		},
		{
			name: "dateMonth",
			pos:  position{line: 227, col: 1, offset: 5788},
			expr: &ruleRefExpr{
				pos:  position{line: 227, col: 14, offset: 5801},
				name: "Digit2",
			},
		},
		{
			name: "dateMday",
			pos:  position{line: 228, col: 1, offset: 5808},
			expr: &ruleRefExpr{
				pos:  position{line: 228, col: 13, offset: 5820},
				name: "Digit2",
			},
		},
		{
			name: "timeHour",
			pos:  position{line: 229, col: 1, offset: 5827},
			expr: &ruleRefExpr{
				pos:  position{line: 229, col: 13, offset: 5839},
				name: "Digit2",
			},
		},
		{
			name: "timeMinute",
			pos:  position{line: 230, col: 1, offset: 5846},
			expr: &ruleRefExpr{
				pos:  position{line: 230, col: 15, offset: 5860},
				name: "Digit2",
			},
		},
		{
			name: "timeSecond",
			pos:  position{line: 231, col: 1, offset: 5867},
			expr: &ruleRefExpr{
				pos:  position{line: 231, col: 15, offset: 5881},
				name: "Digit2",
			},
		},
		{
			name: "timeSecfrac",
			pos:  position{line: 232, col: 1, offset: 5888},
			expr: &seqExpr{
				pos: position{line: 232, col: 16, offset: 5903},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 232, col: 16, offset: 5903},
						val:        ".",
						ignoreCase: false,
						want:       "\".\"",
					},
					&oneOrMoreExpr{
						pos: position{line: 232, col: 20, offset: 5907},
						expr: &charClassMatcher{
							pos:        position{line: 232, col: 20, offset: 5907},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
				},
			},
		},
		{
			name: "timeNumoffset",
			pos:  position{line: 233, col: 1, offset: 5914},
			expr: &seqExpr{
				pos: position{line: 233, col: 18, offset: 5931},
				exprs: []interface{}{
					&choiceExpr{
						pos: position{line: 233, col: 19, offset: 5932},
						alternatives: []interface{}{
							&litMatcher{
								pos:        position{line: 233, col: 19, offset: 5932},
								val:        "+",
								ignoreCase: false,
								want:       "\"+\"",
							},
							&litMatcher{
								pos:        position{line: 233, col: 25, offset: 5938},
								val:        "-",
								ignoreCase: false,
								want:       "\"-\"",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 233, col: 30, offset: 5943},
						name: "timeHour",
					},
					&litMatcher{
						pos:        position{line: 233, col: 39, offset: 5952},
						val:        ":",
						ignoreCase: false,
						want:       "\":\"",
					},
					&ruleRefExpr{
						pos:  position{line: 233, col: 43, offset: 5956},
						name: "timeMinute",
					},
				},
			},
		},
		{
			name: "timeOffset",
			pos:  position{line: 234, col: 1, offset: 5967},
			expr: &choiceExpr{
				pos: position{line: 234, col: 15, offset: 5981},
				alternatives: []interface{}{
					&litMatcher{
						pos:        position{line: 234, col: 15, offset: 5981},
						val:        "z",
						ignoreCase: true,
						want:       "\"Z\"i",
					},
					&ruleRefExpr{
						pos:  position{line: 234, col: 22, offset: 5988},
						name: "timeNumoffset",
					},
				},
			},
		},
		{
			name: "partialTime",
			pos:  position{line: 235, col: 1, offset: 6002},
			expr: &seqExpr{
				pos: position{line: 235, col: 16, offset: 6017},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 235, col: 16, offset: 6017},
						name: "timeHour",
					},
					&litMatcher{
						pos:        position{line: 235, col: 25, offset: 6026},
						val:        ":",
						ignoreCase: false,
						want:       "\":\"",
					},
					&ruleRefExpr{
						pos:  position{line: 235, col: 29, offset: 6030},
						name: "timeMinute",
					},
					&litMatcher{
						pos:        position{line: 235, col: 40, offset: 6041},
						val:        ":",
						ignoreCase: false,
						want:       "\":\"",
					},
					&ruleRefExpr{
						pos:  position{line: 235, col: 44, offset: 6045},
						name: "timeSecond",
					},
					&zeroOrOneExpr{
						pos: position{line: 235, col: 55, offset: 6056},
						expr: &ruleRefExpr{
							pos:  position{line: 235, col: 55, offset: 6056},
							name: "timeSecfrac",
						},
					},
				},
			},
		},
		{
			name: "fullTime",
			pos:  position{line: 236, col: 1, offset: 6069},
			expr: &seqExpr{
				pos: position{line: 236, col: 13, offset: 6081},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 236, col: 13, offset: 6081},
						name: "partialTime",
					},
					&ruleRefExpr{
						pos:  position{line: 236, col: 25, offset: 6093},
						name: "timeOffset",
					},
				},
			},
		},
		{
			name: "Digit4",
			pos:  position{line: 237, col: 1, offset: 6104},
			expr: &seqExpr{
				pos: position{line: 237, col: 11, offset: 6114},
				exprs: []interface{}{
					&charClassMatcher{
						pos:        position{line: 237, col: 11, offset: 6114},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 237, col: 16, offset: 6119},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 237, col: 21, offset: 6124},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 237, col: 26, offset: 6129},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "Digit2",
			pos:  position{line: 238, col: 1, offset: 6135},
			expr: &seqExpr{
				pos: position{line: 238, col: 11, offset: 6145},
				exprs: []interface{}{
					&charClassMatcher{
						pos:        position{line: 238, col: 11, offset: 6145},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 238, col: 16, offset: 6150},
						val:        "[0-9]",
						ranges:     []rune{'0', '9'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "logicalOR",
			pos:  position{line: 244, col: 1, offset: 6213},
			expr: &litMatcher{
				pos:        position{line: 244, col: 14, offset: 6226},
				val:        "OR",
				ignoreCase: false,
				want:       "\"OR\"",
			},
		},
		{
			name: "logicalAND",
			pos:  position{line: 246, col: 1, offset: 6232},
			expr: &litMatcher{
				pos:        position{line: 246, col: 15, offset: 6246},
				val:        "AND",
				ignoreCase: false,
				want:       "\"AND\"",
			},
		},
		{
			name: "logicalNOT",
			pos:  position{line: 248, col: 1, offset: 6253},
			expr: &choiceExpr{
				pos: position{line: 248, col: 15, offset: 6267},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 248, col: 15, offset: 6267},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 248, col: 15, offset: 6267},
								val:        "NOT",
								ignoreCase: false,
								want:       "\"NOT\"",
							},
							&ruleRefExpr{
								pos:  position{line: 248, col: 21, offset: 6273},
								name: "space",
							},
						},
					},
					&seqExpr{
						pos: position{line: 248, col: 29, offset: 6281},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 248, col: 29, offset: 6281},
								val:        "!",
								ignoreCase: false,
								want:       "\"!\"",
							},
							&zeroOrOneExpr{
								pos: position{line: 248, col: 33, offset: 6285},
								expr: &ruleRefExpr{
									pos:  position{line: 248, col: 33, offset: 6285},
									name: "space",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "opCOMP",
			pos:  position{line: 254, col: 1, offset: 6358},
			expr: &choiceExpr{
				pos: position{line: 254, col: 11, offset: 6368},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 254, col: 11, offset: 6368},
						name: "opCustom",
					},
					&actionExpr{
						pos: position{line: 255, col: 3, offset: 6379},
						run: (*parser).callonopCOMP3,
						expr: &litMatcher{
							pos:        position{line: 255, col: 3, offset: 6379},
							val:        "><",
							ignoreCase: false,
							want:       "\"><\"",
						},
					},
					&actionExpr{
						pos: position{line: 257, col: 5, offset: 6421},
						run: (*parser).callonopCOMP5,
						expr: &charClassMatcher{
							pos:        position{line: 257, col: 5, offset: 6421},
							val:        "[~]",
							chars:      []rune{'~'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&actionExpr{
						pos: position{line: 259, col: 5, offset: 6462},
						run: (*parser).callonopCOMP7,
						expr: &seqExpr{
							pos: position{line: 259, col: 5, offset: 6462},
							exprs: []interface{}{
								&charClassMatcher{
									pos:        position{line: 259, col: 5, offset: 6462},
									val:        "[<>]",
									chars:      []rune{'<', '>'},
									ignoreCase: false,
									inverted:   false,
								},
								&zeroOrOneExpr{
									pos: position{line: 259, col: 10, offset: 6467},
									expr: &litMatcher{
										pos:        position{line: 259, col: 10, offset: 6467},
										val:        "=",
										ignoreCase: false,
										want:       "\"=\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "opCustom",
			pos:  position{line: 263, col: 1, offset: 6509},
			expr: &actionExpr{
				pos: position{line: 263, col: 13, offset: 6521},
				run: (*parser).callonopCustom1,
				expr: &seqExpr{
					pos: position{line: 263, col: 13, offset: 6521},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 263, col: 13, offset: 6521},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&labeledExpr{
							pos:   position{line: 263, col: 17, offset: 6525},
							label: "opname",
							expr: &oneOrMoreExpr{
								pos: position{line: 263, col: 24, offset: 6532},
								expr: &charClassMatcher{
									pos:        position{line: 263, col: 24, offset: 6532},
									val:        "[a-z]i",
									ranges:     []rune{'a', 'z'},
									ignoreCase: true,
									inverted:   false,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 263, col: 32, offset: 6540},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
					},
				},
			},
		},
		{
			name:        "_",
			displayName: "\"whitespace\"",
			pos:         position{line: 271, col: 1, offset: 6650},
			expr: &zeroOrMoreExpr{
				pos: position{line: 271, col: 19, offset: 6668},
				expr: &charClassMatcher{
					pos:        position{line: 271, col: 19, offset: 6668},
					val:        "[ \\n\\t\\r]",
					chars:      []rune{' ', '\n', '\t', '\r'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name: "space",
			pos:  position{line: 273, col: 1, offset: 6680},
			expr: &oneOrMoreExpr{
				pos: position{line: 273, col: 10, offset: 6689},
				expr: &charClassMatcher{
					pos:        position{line: 273, col: 10, offset: 6689},
					val:        "[ \\n\\t\\r]",
					chars:      []rune{' ', '\n', '\t', '\r'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name: "EOL",
			pos:  position{line: 275, col: 1, offset: 6701},
			expr: &litMatcher{
				pos:        position{line: 275, col: 7, offset: 6709},
				val:        "\n",
				ignoreCase: false,
				want:       "\"\\n\"",
			},
		},
		{
			name: "EOF",
			pos:  position{line: 277, col: 1, offset: 6715},
			expr: &notExpr{
				pos: position{line: 277, col: 7, offset: 6721},
				expr: &anyMatcher{
					line: 277, col: 8, offset: 6722,
				},
			},
		},
	},
}

func (c *current) onStart1(query interface{}) (interface{}, error) {
	return query, nil
}

func (p *parser) callonStart1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStart1(stack["query"])
}

func (c *current) onQuery1(clause interface{}) (interface{}, error) {
	return clause, nil
}

func (p *parser) callonQuery1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuery1(stack["clause"])
}

func (c *current) onOrClause2(lhs, rhs interface{}) (interface{}, error) {
	return &Node{
		NodeType: NodeOr,
		Left:     lhs.(*Node),
		Right:    rhs.(*Node),
	}, nil
}

func (p *parser) callonOrClause2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrClause2(stack["lhs"], stack["rhs"])
}

func (c *current) onAndClause2(lhs, rhs interface{}) (interface{}, error) {
	return &Node{
		NodeType: NodeAnd,
		Left:     lhs.(*Node),
		Right:    rhs.(*Node),
	}, nil
}

func (p *parser) callonAndClause2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAndClause2(stack["lhs"], stack["rhs"])
}

func (c *current) onNotClause2(cmp interface{}) (interface{}, error) {
	return &Node{
		NodeType: NodeNot,
		Left:     cmp.(*Node),
		Right:    nil,
	}, nil
}

func (p *parser) callonNotClause2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNotClause2(stack["cmp"])
}

func (c *current) onComparison2(query interface{}) (interface{}, error) {
	return query, nil
}

func (p *parser) callonComparison2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onComparison2(stack["query"])
}

func (c *current) onComparison12(field, operation, values interface{}) (interface{}, error) {
	var opOut string
	if operation == nil {
		opOut = "=="
	} else {
		opOut = operation.(string)
	}
	return &Node{
		NodeType: NodeTerminal,
		Comparison: Comparison{
			Op:     opOut,
			Field:  field.([]string),
			Values: values.([]string),
		},
	}, nil
}

func (p *parser) callonComparison12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onComparison12(stack["field"], stack["operation"], stack["values"])
}

func (c *current) onField1(pieces interface{}) (interface{}, error) {
	piecesSl := toIfaceSlice(pieces)
	if len(piecesSl) == 0 {
		return nil, fmt.Errorf("empty field")
	}
	field := []string{piecesSl[0].(string)}
	restSl := toIfaceSlice(piecesSl[1])
	for _, v := range restSl {
		vSl := toIfaceSlice(v)
		field = append(field, vSl[1].(string))
	}
	return field, nil
}

func (p *parser) callonField1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onField1(stack["pieces"])
}

func (c *current) onUnquotedFieldPiece1() (interface{}, error) {
	return string(c.text), nil
}

func (p *parser) callonUnquotedFieldPiece1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnquotedFieldPiece1()
}

func (c *current) onStar1() (interface{}, error) {
	return "*", nil
}

func (p *parser) callonStar1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStar1()
}

func (c *current) onValueList2(first, rest interface{}) (interface{}, error) {
	return getTokens(first, rest, 3), nil
}

func (p *parser) callonValueList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onValueList2(stack["first"], stack["rest"])
}

func (c *current) onValueList21(value interface{}) (interface{}, error) {
	return []string{value.(string)}, nil
}

func (p *parser) callonValueList21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onValueList21(stack["value"])
}

func (c *current) onValue4() (interface{}, error) {
	return string(c.text), nil
}

func (p *parser) callonValue4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onValue4()
}

func (c *current) onQuotedValue1() (interface{}, error) {
	c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
	return strconv.Unquote(string(c.text))
}

func (p *parser) callonQuotedValue1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuotedValue1()
}

func (c *current) onRegexValue1() (interface{}, error) {
	c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
	// TODO: below is handled in jsonquery at the moment, revisit when converting stuff to types
	// return c.text = c.text[1:len(c.text)-1], nil
	return string(c.text), nil
}

func (p *parser) callonRegexValue1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRegexValue1()
}

func (c *current) onCIDRValue1() (interface{}, error) {
	// we don't want to do anything heavy in the parser, just assert that
	// barewords more or less conform. Actual parsing will be done when building
	// the query. This can be moved into the parser later
	return string(c.text), nil
}

func (p *parser) callonCIDRValue1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCIDRValue1()
}

func (c *current) onopCOMP3() (interface{}, error) {
	return string(c.text), nil
}

func (p *parser) callonopCOMP3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onopCOMP3()
}

func (c *current) onopCOMP5() (interface{}, error) {
	return string(c.text), nil
}

func (p *parser) callonopCOMP5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onopCOMP5()
}

func (c *current) onopCOMP7() (interface{}, error) {

	return string(c.text), nil
}

func (p *parser) callonopCOMP7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onopCOMP7()
}

func (c *current) onopCustom1(opname interface{}) (interface{}, error) {
	return toString(opname)
}

func (p *parser) callonopCustom1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onopCustom1(stack["opname"])
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expresssions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return MaxExpressions(oldMaxExprCnt)
	}
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return Entrypoint(oldEntrypoint)
	}
}

// Statistics adds a user provided Stats struct to the parser to allow
// the user to process the results after the parsing has finished.
// Also the key for the "no match" counter is set.
//
// Example usage:
//
//     input := "input"
//     stats := Stats{}
//     _, err := Parse("input-file", []byte(input), Statistics(&stats, "no match"))
//     if err != nil {
//         log.Panicln(err)
//     }
//     b, err := json.MarshalIndent(stats.ChoiceAltCnt, "", "  ")
//     if err != nil {
//         log.Panicln(err)
//     }
//     fmt.Println(string(b))
//
func Statistics(stats *Stats, choiceNoMatch string) Option {
	return func(p *parser) Option {
		oldStats := p.Stats
		p.Stats = stats
		oldChoiceNoMatch := p.choiceNoMatch
		p.choiceNoMatch = choiceNoMatch
		if p.Stats.ChoiceAltCnt == nil {
			p.Stats.ChoiceAltCnt = make(map[string]map[string]int)
		}
		return Statistics(oldStats, oldChoiceNoMatch)
	}
}

// Debug creates an Option to set the debug flag to b. When set to true,
// debugging information is printed to stdout while parsing.
//
// The default is false.
func Debug(b bool) Option {
	return func(p *parser) Option {
		old := p.debug
		p.debug = b
		return Debug(old)
	}
}

// Memoize creates an Option to set the memoize flag to b. When set to true,
// the parser will cache all results so each expression is evaluated only
// once. This guarantees linear parsing time even for pathological cases,
// at the expense of more memory and slower times for typical cases.
//
// The default is false.
func Memoize(b bool) Option {
	return func(p *parser) Option {
		old := p.memoize
		p.memoize = b
		return Memoize(old)
	}
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return AllowInvalidUTF8(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return Recover(old)
	}
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value interface{}) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return GlobalStore(key, old)
	}
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value interface{}) Option {
	return func(p *parser) Option {
		old := p.cur.state[key]
		p.cur.state[key] = value
		return InitState(key, old)
	}
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i interface{}, err error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil {
			err = closeErr
		}
	}()
	return ParseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (interface{}, error) {
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return Parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (interface{}, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// state is a store for arbitrary key,value pairs that the user wants to be
	// tied to the backtracking of the parser.
	// This is always rolled back if a parsing rule fails.
	state storeDict

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict
}

type storeDict map[string]interface{}

// the AST types...

type grammar struct {
	pos   position
	rules []*rule
}

type rule struct {
	pos         position
	name        string
	displayName string
	expr        interface{}
}

type choiceExpr struct {
	pos          position
	alternatives []interface{}
}

type actionExpr struct {
	pos  position
	expr interface{}
	run  func(*parser) (interface{}, error)
}

type recoveryExpr struct {
	pos          position
	expr         interface{}
	recoverExpr  interface{}
	failureLabel []string
}

type seqExpr struct {
	pos   position
	exprs []interface{}
}

type throwExpr struct {
	pos   position
	label string
}

type labeledExpr struct {
	pos   position
	label string
	expr  interface{}
}

type expr struct {
	pos  position
	expr interface{}
}

type andExpr expr
type notExpr expr
type zeroOrOneExpr expr
type zeroOrMoreExpr expr
type oneOrMoreExpr expr

type ruleRefExpr struct {
	pos  position
	name string
}

type stateCodeExpr struct {
	pos position
	run func(*parser) error
}

type andCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type notCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

type charClassMatcher struct {
	pos             position
	val             string
	basicLatinChars [128]bool
	chars           []rune
	ranges          []rune
	classes         []*unicode.RangeTable
	ignoreCase      bool
	inverted        bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			state:       make(storeDict),
			globalStore: make(storeDict),
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
	}
	p.setOptions(opts)

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

type resultTuple struct {
	v   interface{}
	b   bool
	end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool
	debug   bool

	memoize bool
	// memoization table for the packrat algorithm:
	// map[offset in source] map[expression or rule] {value, match}
	memo map[int]map[interface{}]resultTuple

	// rules table, maps the rule identifier to the rule node
	rules map[string]*rule
	// variables stack, map of label to value
	vstack []map[string]interface{}
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]interface{}
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]interface{})
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr interface{}) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]interface{}, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) print(prefix, s string) string {
	if !p.debug {
		return s
	}

	fmt.Printf("%s %d:%d:%d: %s [%#U]\n",
		prefix, p.pt.line, p.pt.col, p.pt.offset, s, p.pt.rn)
	return s
}

func (p *parser) in(s string) string {
	p.depth++
	return p.print(strings.Repeat(" ", p.depth)+">", s)
}

func (p *parser) out(s string) string {
	p.depth--
	return p.print(strings.Repeat(" ", p.depth)+"<", s)
}

func (p *parser) addErr(err error) {
	p.addErrAt(err, p.pt.position, []string{})
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if p.debug {
		defer p.out(p.in("restore"))
	}
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
	Clone() interface{}
}

var statePool = &sync.Pool{
	New: func() interface{} { return make(storeDict) },
}

func (sd storeDict) Discard() {
	for k := range sd {
		delete(sd, k)
	}
	statePool.Put(sd)
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict {
	if p.debug {
		defer p.out(p.in("cloneState"))
	}

	state := statePool.Get().(storeDict)
	for k, v := range p.cur.state {
		if c, ok := v.(Cloner); ok {
			state[k] = c.Clone()
		} else {
			state[k] = v
		}
	}
	return state
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) {
	if p.debug {
		defer p.out(p.in("restoreState"))
	}
	p.cur.state.Discard()
	p.cur.state = state
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) getMemoized(node interface{}) (resultTuple, bool) {
	if len(p.memo) == 0 {
		return resultTuple{}, false
	}
	m := p.memo[p.pt.offset]
	if len(m) == 0 {
		return resultTuple{}, false
	}
	res, ok := m[node]
	return res, ok
}

func (p *parser) setMemoized(pt savepoint, node interface{}, tuple resultTuple) {
	if p.memo == nil {
		p.memo = make(map[int]map[interface{}]resultTuple)
	}
	m := p.memo[pt.offset]
	if m == nil {
		m = make(map[interface{}]resultTuple)
		p.memo[pt.offset] = m
	}
	m[node] = tuple
}

func (p *parser) buildRulesTable(g *grammar) {
	p.rules = make(map[string]*rule, len(g.rules))
	for _, r := range g.rules {
		p.rules[r.name] = r
	}
}

func (p *parser) parse(g *grammar) (val interface{}, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.buildRulesTable(g)

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				if p.debug {
					defer p.out(p.in("panic handler"))
				}
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	startRule, ok := p.rules[p.entrypoint]
	if !ok {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	val, ok = p.parseRule(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRule(rule *rule) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseRule " + rule.name))
	}

	if p.memoize {
		res, ok := p.getMemoized(rule)
		if ok {
			p.restore(res.end)
			return res.v, res.b
		}
	}

	start := p.pt
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExpr(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	if ok && p.debug {
		p.print(strings.Repeat(" ", p.depth)+"MATCH", string(p.sliceFrom(start)))
	}

	if p.memoize {
		p.setMemoized(start, rule, resultTuple{val, ok, p.pt})
	}
	return val, ok
}

func (p *parser) parseExpr(expr interface{}) (interface{}, bool) {
	var pt savepoint

	if p.memoize {
		res, ok := p.getMemoized(expr)
		if ok {
			p.restore(res.end)
			return res.v, res.b
		}
		pt = p.pt
	}

	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val interface{}
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *stateCodeExpr:
		val, ok = p.parseStateCodeExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	if p.memoize {
		p.setMemoized(pt, expr, resultTuple{val, ok, p.pt})
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseActionExpr"))
	}

	start := p.pt
	val, ok := p.parseExpr(act.expr)
	if ok {
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		state := p.cloneState()
		actVal, err := act.run(p)
		if err != nil {
			p.addErrAt(err, start.position, []string{})
		}
		p.restoreState(state)

		val = actVal
	}
	if ok && p.debug {
		p.print(strings.Repeat(" ", p.depth)+"MATCH", string(p.sliceFrom(start)))
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseAndCodeExpr"))
	}

	state := p.cloneState()

	ok, err := and.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseAndExpr"))
	}

	pt := p.pt
	state := p.cloneState()
	p.pushV()
	_, ok := p.parseExpr(and.expr)
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseAnyMatcher"))
	}

	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseCharClassMatcher"))
	}

	cur := p.pt.rn
	start := p.pt

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) incChoiceAltCnt(ch *choiceExpr, altI int) {
	choiceIdent := fmt.Sprintf("%s %d:%d", p.rstack[len(p.rstack)-1].name, ch.pos.line, ch.pos.col)
	m := p.ChoiceAltCnt[choiceIdent]
	if m == nil {
		m = make(map[string]int)
		p.ChoiceAltCnt[choiceIdent] = m
	}
	// We increment altI by 1, so the keys do not start at 0
	alt := strconv.Itoa(altI + 1)
	if altI == choiceNoMatch {
		alt = p.choiceNoMatch
	}
	m[alt]++
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseChoiceExpr"))
	}

	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		state := p.cloneState()

		p.pushV()
		val, ok := p.parseExpr(alt)
		p.popV()
		if ok {
			p.incChoiceAltCnt(ch, altI)
			return val, ok
		}
		p.restoreState(state)
	}
	p.incChoiceAltCnt(ch, choiceNoMatch)
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseLabeledExpr"))
	}

	p.pushV()
	val, ok := p.parseExpr(lab.expr)
	p.popV()
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		m[lab.label] = val
	}
	return val, ok
}

func (p *parser) parseLitMatcher(lit *litMatcher) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseLitMatcher"))
	}

	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseNotCodeExpr"))
	}

	state := p.cloneState()

	ok, err := not.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseNotExpr"))
	}

	pt := p.pt
	state := p.cloneState()
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	_, ok := p.parseExpr(not.expr)
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseOneOrMoreExpr"))
	}

	var vals []interface{}

	for {
		p.pushV()
		val, ok := p.parseExpr(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseRecoveryExpr (" + strings.Join(recover.failureLabel, ",") + ")"))
	}

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExpr(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseRuleRefExpr " + ref.name))
	}

	if ref.name == "" {
		panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))
	}

	rule := p.rules[ref.name]
	if rule == nil {
		p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
		return nil, false
	}
	return p.parseRule(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseSeqExpr"))
	}

	vals := make([]interface{}, 0, len(seq.exprs))

	pt := p.pt
	state := p.cloneState()
	for _, expr := range seq.exprs {
		val, ok := p.parseExpr(expr)
		if !ok {
			p.restoreState(state)
			p.restore(pt)
			return nil, false
		}
		vals = append(vals, val)
	}
	return vals, true
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseStateCodeExpr"))
	}

	err := state.run(p)
	if err != nil {
		p.addErr(err)
	}
	return nil, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseThrowExpr"))
	}

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExpr(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseZeroOrMoreExpr"))
	}

	var vals []interface{}

	for {
		p.pushV()
		val, ok := p.parseExpr(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (interface{}, bool) {
	if p.debug {
		defer p.out(p.in("parseZeroOrOneExpr"))
	}

	p.pushV()
	val, _ := p.parseExpr(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}
